# 쓰레드 문제

쓰레드로 인한 대표적인 문제는 다음과 같습니다.

## 1. Race Condition

멀티 쓰레드 환경에서 하나 이상의 공유 테이터를 처리하게 되면 여러 쓰레드가 동시에 데이터를 수정할 수 있는데 하나의 쓰레드에서 데이터를 처리하고자 할 때 데이터가 꼬여 무한 대기 또는 무한 루프에 빠지는 현상을 이야기 합니다. 우선 순위을 지정하지만 많이 피할 수 있지만 설정 하여도 없어진다는 보장은 없습니다.

## 2. DeadLock

두 개 이상의 쓰레드에서 락이 서로 풀기만을 기다리는 상황으로 CPU를 점유하지 않고 멈춤

## 3. Statvation

쓰레드가 이론적으로 데이터 처리할 수 있지만 CPU에서 프로세스흫 할당 받지 못해 멈추어 지는 상황으로 우선 순위가 다른 쓰레드보다 낮은 해당 쓰레드는 스터베이션에 빠질 수 있다. 잘못 설정한 쓰레드 우선 순위에서 발생 하므로 우선 순위는 되도록 건들지 않아야 합니다.

## 4. Live Lock

쓰레드 1이 쓰레드 2로 응답으로 주고 쓰레드 2가 쓰레드 1로 다시 요청을 보내는 작업이 계속 반복되는 것으로 CPU까지 잡아먹을 확율이 높다.

## 5. 예측 불가능한 오류

예측 가능한 값이라 생각하지만 결과가 틀리게 나오는 작업으로 보통 트랜잰션을 처리 하는 부분이 꼬이면 발생합니다.

## 6. Lock를 피할 수 있는 방법

1. **크드가 아닌 데이터를 보호해라** \
   \- synchronized는 로직이 아닌 데이터만 블럭으로 감싼다.\
   \- 업무 처리 로직은 시간이 걸리므로 데이터만 블럭으로 감싸서 시간을 줄 입니다.
2. **락을 사용한 부분에서는 시간이 많이 소요되는 계싼을 하지 말라**\
   \- I/O 작업을 피한다.
3. **락을 분리하라** \
   \- 전체 보다는 부분을 배열 처리 업무에서 배열 전채 보다는 요소 처리에 락을 잡아라\
   \- 서로 다른 데이터에는 서로 다른 락을 사용합니다.
4. **내부적인 락이나 atomic 작업을 사용하라**\
   \- 가능 하면 atomic 연산을 이용합니다.
5. **동기화 된 데이터 구조를 사용해라**
6. **가능 하다면 읽기-쓰기 락을 사용해라** \
   \- 읽기 작업만 많이 수행하는 사용자는 동시 처리를 쓰기 작업이 필요한 사용자는 락을 걸어 처리 하도록 합니다.
7. **가능 하다면 읽기 전용 데이터를 사용해라** \
   \- 병렬 프로그램에서 많은 데이터를 락을 걸지 않고 모든 쓰레드에서 접근 가능한 읽기 전용 데이터를 만들 수 있다면 전용 읽기 데이터를 만들어 사용합니다.
8. **객체 폴링을 피하라**\
   \- 객체 재사용을 위해서 만드는 객체 폴링은 데이터 보호 측면에서 문제가 발생할 수 있다. 객체 폴링은 필요한 경우만 사용해라
9. **지역 변수나 쓰레드 로컬 저장소를 사용하라** \
   \- 공유 객체는 문제를 발생 합니다. 쓰레드 내부에서 사용하는 객체를 만들어 사용 해라&#x20;
10. **핫스팟을 피하라**\
    \- 핫스팟이란 리스트 계열 계열에서 크기를 저장하는 변수가 수정되고 그 작업을 수행하는 메서드로 동시 접근 처리를 보호되어야 하는 것을 의미 합니다. 목록의 크기를 저장 하는 변수가 없으면 발생 하지 않습니다.&#x20;











