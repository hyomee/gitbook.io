# CleanCode

> 르블랑의 법칙(Leblanc's Law) : 나중은 결코 오지 않는다.

***

"다음에 뭐 해야지"라고 생각하고 미룬 일을 한 적이 얼마나 있는지요. 개발 일정, 업무 가 어려워서 등 많은 이유로 우선 개발해서 돌아가는 것 확인 하고 나서  다음에 최적화해야지 하고 개발한 코드는 문제없이 수행되는 순간 살아 생명이 부여된 코드로 쉽게 변경을 할 수 없습니다. 만약 나쁜 코드로 작성이 되었으면 많은 대가라 따른다.

1. 코드 수정 시 수정된 부분이 아닌 전혀 틀린 부분에서 에러가 난다.&#x20;
2. 수정이 많을 수록 해독 불가, 나중에는 수정 불가 ( 완변한 스파게티... )
3. 나쁜 코드는 여러 변경 사항에 대해서 반응이 느려 생상성이 떨어진다
4. 재 개발에 따른 비용 증가&#x20;

***

> 전문가는 언제나 코드를 최대한 깨끗하게 유지하는 습관을 가진다.

***

## 1. 깨끗한 코드란?

**비야네 스트롭스르룹**

* 우아한 효율적인 코드
* 논리가 간단해야 버그가 숨어들지 못한다.
* 위존성을 최대한 줄여야 유지 보수 쉬워진다.
* 오류는 명백한 전략에 의거해 철저리 처리&#x20;
* 성능은 유지하고 원칙 없는 최적화하는 코드는 망친다.
* 깨끗한 코드는 한 가지를 제대로&#x20;

> 깨진 창문 효과 : 깨진 창문은 더 깨져도 상관하지 않는다, 나중에는 깨지고 없어진다.

**그레디 부치**

* 깨끗한 코드는 단순하고 직접적이다.
* 읽기 쉬운 코드이며 명쾌한 추상화와 단순한 제어문으로 가득하다.&#x20;

**데이브 토마스**

* 깨끗한 코드는 읽기 쉽고 고치기 쉽다. ( 읽기 쉬운 코드와 고치기 쉬운 코드는 틀린다.)
* 단위 테스트 케이스와 인수 테스트 게이스가 존재한다. ( 테스트 주도 개발 \[TDD})
* 의미 있는 이름을 사용하며, 목적은 하나만 제공한다.&#x20;
* 의존성은 최소이며 명확히 정의한다. ( 큰 코드보다는 작은 코드로 )

**마이클 페더스**

* 깨끗한 코드는 주의 깊게 작성을 하며 딱히 손댈 곳이 없다.
* 모든 사항을 고려하여 작성&#x20;

**론 제프리스**

* 깨끗한 코드는 단순하고 중복이 없다. ( 리팩터링을 통해서 \[메서드 추출 기법] )
* 모든 테스트를 통과한다.
* 시스템 내의 모든 설계 아이디어를 표현한다.
* 클래스, 메서드, 함수 등을 최대한 줄인다.&#x20;

**워드 커닝햄**

* 깨끗한 코드는 짐작했던 기능을 각 루틴이 그대로 수행하는 것
* 모든 테스트를 통과한다.
* 시스템 내의 모든 설계 아이디어를 표현한다.
* 클래스, 메서드, 함수 등을 최대한 줄인다.&#x20;

오브젝트 멘토 진영이 생각하는 깨끗한 코드를 설명한 도서로 믿고 실천한 것이 지만 무조건 옳다고 주장하지 않는다. 선배 개발자들의 경험과 반복적인 시행착오로 습득한 교훈과 기법을 권고한다.

프로그램은 책을 쓰는 저자이다 Javadoc의 @author필드는 저자를 소개하는 것으로 작성이 되면 책임이 따르며 코드를 작성할 때 작성한 코드든 수 없이 읽게 되므로 읽기 쉬운 코드로 작성을 해야 하며 다른 개발자를 위해서 깨끗한 코드를 작성해야 한다.&#x20;

> 보이스카우트 규칙 : 캠프장은 처음 왔을 때보다 더 깨듯 하게 하고 떠너라&#x20;

***

## 2. 프리퀄(prequel)

Agile Software Development : 원칙(Principles), 패턴(Patterns), and 관행(Practices)

**애자일 소프트웨어 개발 선언**

우리는 소프트웨어를 개발하고, 또 다른 사람의 개발을 도와주면서 소프트웨어 개발의 더 나은 방법들을 찾아가고 있다. 이 작업을 통해 우리는 다음을 가치 있게 여기게 되었다:

* 공정과 도구보다 개인과 상호작용을
* 포괄적인 문서보다 작동하는 소프트웨어를
* 계약 협상보다 고객과의 협력을
* 계획을 따르기보다 변화에 대응하기를

가치 있게 여긴다

**객체지향 설계 5원칙 SOLID**

* SRP(Single Responsibility Principle): 단일 책임 원칙 : 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다.
* OCP(Open Closed Priciple): 개방 폐쇄 원칙 : 클래스는 확장에 열려 있어야 하며 변경에 닫혀 있어야 한다.
* LSP(Listov Substitution Priciple): 리스 코프 치환 원칙 : 상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.
* ISP(Interface Segregation Principle): 인터페이스 분리 원칙 : 추상화에 의존해야 하며, 구체화에 의존하면 안 된다.
* DIP(Dependency Inversion Principle): 의존 역전 원칙 : 클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.

참고 : [SOLID (객체 지향 설계)](https://ko.wikipedia.org/wiki/SOLID\_\(%EA%B0%9D%EC%B2%B4\_%EC%A7%80%ED%96%A5\_%EC%84%A4%EA%B3%84\))

## 3. 의미있는 이름

프로그램 작성 시 가장 어려운 것 하나가 변수, 클래스 등의 이름을 붙이는 것으로 이름을 짓는 간단한 규칙을 소개한다,

**1. 의도를 분명히 밝혀라**&#x20;

프로그램은 작성 후  요구 사항 변경에 따른 기능 변경, 요구 사항 추가에 따른 기능 추가, 버그에 따른 수정 등 많은 이유로 변경을 하는 일은 유지 보수 팀을 하게 된다. 최초 개발자가 하는 경우도 있지만 그렇지 않은 경우가 많다. 또한 멉무를 모르는 개발자가 수정할 수도 있는데 이때 의미를 알 수 없는 변수명이나 클래스명으로 인해서 프로그램을 해석하고 파악하는데 시간이 많이 소요하게 된다. 프로그램은 살아 있는 생명과 같아서 언제나 변경이 가능하고 기능을 추가할 수 있어서 사람의 이름처럼 분명한 의미를 부여하여야 하고 읽기 쉽게 작성이 되어야 한다.

> 예) 자동차 속도가 80Km 이상이면 경고를 표시한다.\
> String warningSign(int sp) {\
> &#x20;  if ( sp > 80 ) {\
> &#x20;     return "경고...";\
> &#x20;  }\
> }\
> // 소스 변경 \
> static final MAX\_WARNNING\_SPEED = 80;\
> static final SPEED\_OVER\_WARNNING\_MESSAGE = "경고";\
> \
> String warningSign(int carSpeed) {\
> &#x20;  if ( carSpeed > MAX\_WARNNING\_SPEED) {\
> &#x20;     return SPEED\_OVER\_WARNNING\_MESSAGE;\
> &#x20;  }\
> }

***

**2. 그릇된 정보를 피하라**&#x20;

프로그램 코드는 변수, 글라스 등 정보를 보관하기 위해서 사용하게 되는데 명명을 잘못하면 코드를 해석하는 시간이 많이 소요됩니다. 또한  한 문자로 되어 있는 명은 코드를 읽는데 잘못 해석될 수 있어서 피해야 합니다.

> // 숫자 0과 영문자 O는 구분하기 힘들다,\
> int a = 1;\
> if ( o == 1 ) {\
> &#x20;  a = 01;\
> } else {\
> &#x20;  a = O1\
> }

***

**3. 의미 있게 구분하라**&#x20;

고객정보룰 얻어 오는 메서드를 만들다고 가정한다면 다음과 같습니다,

getCustomer();\
getCustomers();\
getCustomerInfo();

어떤 메서드를 사용해야지 고객정보를 가지고 올 수 있을까요? \
코드를 읽는 사람이 차이를 알도록 이름을 지어야 합니다,

***

**4. 발을 하기 쉬운 이름을 사용하라.**\
**5. 검색하기 쉬운 이름을 사용하라.**\
**6. 클래스 이름은 명사를 사용하라.**\
**7. 메서드 이름은 동사나 동사구를 사용하라.**\
**8. 기발 안 이름은 피하라.** \
**9. 말장난을 하지 마라.**\
**10. 해법 영역에서 가져온 이름을 사용하라.**\


코드를 읽는 사람은 개발자로 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 되지만 모든 이름을 문제 영역(Domain)에서 가져오는 것은 피해야 한다.

**11. 문제 영역에서 가져온 이름을 사용하라**

문제 영역(Domain)이 있다면 문제 영역에서 이름을 가져와서 사용해야 한다

**12. 의미 있는 맥락을 추가하라**

단어를 조합해서 아름을 사용할 경우 firstName, lastName등과 같이 의미 있는 부여 해야 한다, 그냥 status, speed와 같은 명울 사용하면 의미 파악이 힘들어진다.

**13. 불필요한 맥락을 없애라**&#x20;

고객정보를 담는 변수는 customer이면 되는데 굳이 판매 모듈의 고객 정보라고 SaleCustomer로 표현할 필요는 없다.

***

**자바 빈 규약**

자바 빈은 자바빈 규약(관례, 규칙) 을 따르는 클래스라이며 다음과 같은 규칙들이 있습니다.

1\. 패키지 - 자바 빈은 기본(default)패키지 이외의 특정 패키지에 속해 있어야 한다.\
&#x20;\- 자바빈은 기본 패키지가 아닌 특정한 패키지에 속해 있어야 합니다.

2\. 기본 생성자가 존재해야 한다.\
\- 자바빈은 다음과 같이 오버 로딩되지 않은, 즉 매개변수 값이 없는 기본 생성자가 존재해야 합니다.

3\. 멤버 변수의 접근제어자는 private로 선언되어야 한다.\
&#x20;\- 멤버 변수는 직접 접근할 수 없도록 private로 선언되어야 합니다.

4\. 멤버 변수에 접근 가능한 getter 와 setter 메서드가 존재해야 한다.\
&#x20;\- 멤버변수에 접근 가능한 getter 메서드와 setter 메서드 필요하며 작성 시getter의 경우 get멤버변수이름 setter의 경우에는 set멤버변수이름set멤버 변수 이름과 같은 식으로 작성해야 하고 set, get 다음을 대문자로 시작합니다. ( setName(), getName() )\
&#x20;\- boolean 형의 getter는is로 시작한다

5\. getter와 setter는 접근자가 public으로 선언되어야 한다.\
&#x20;\- getter와 setter는 어느 패키지에서나 접근 가능하도록 public으로 선언되어야 합니다.\


6\. 직렬화 되어 있어야 한다. (선택사항)\
&#x20;\- 객체 직렬화란 객체를 입출력에 사용할 수 있도록 객체의 멤버들을 바이트 형태로 변환시키는 것입니다.\
&#x20;\- java.io.Serializable 인터페이스를 상속하여 직렬화할 수 있습니다.\
&#x20;\- 객체를 바이트 스트림으로 변환하는 것을 마샬링 이라고 하며, 반대로 객체화 하는것을 언마샬링이라고 합니다

***

**POJO ( Plain Old Java Object )**

Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어로 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트 즉 본래 자바의 장점을 살리는 '오래된' 방식의 '순수한' 자바 객체&#x20;

**자바 코드 스타일 :** [**https://google.github.io/styleguide/javaguide.html**](https://google.github.io/styleguide/javaguide.html)

